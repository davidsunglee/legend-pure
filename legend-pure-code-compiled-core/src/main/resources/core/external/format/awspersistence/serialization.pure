// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::persistence::metamodel::*;
import meta::legend::service::metamodel::*;
import meta::pure::persistence::metamodel::trigger::*;
import meta::pure::persistence::metamodel::notifier::*;
import meta::pure::persistence::metamodel::persister::*;
import meta::pure::persistence::metamodel::persister::targetshape::*;
import meta::pure::persistence::metamodel::persister::deduplication::*;
import meta::pure::persistence::metamodel::persister::ingestmode::snapshot::*;
import meta::pure::persistence::metamodel::persister::audit::*;
import meta::pure::persistence::metamodel::persister::transactionmilestoning::*;

import meta::external::format::awspersistence::metamodel::*;
import meta::external::format::awspersistence::serialization::*;
import meta::pure::functions::meta::*;
import meta::pure::runtime::*;


function  meta::external::format::awspersistence::serialization::serialize(p: Persistence[1]): meta::external::format::awspersistence::metamodel::AwsPersistence[1]
{
  let notifier = $p.notifier;
  let nonpd = $notifier.notifyees->filter(n|!$n->instanceOf(PagerDutyNotifyee));
  assertEmpty($nonpd, | 'AwsPersistence can currently only support PagerDuty notifees');

  assert($p.persister->instanceOf(BatchPersister), | 'AwsPersistence can currently only handle batch persistence');
  let bp = $p.persister->cast(@BatchPersister);

  let apt = serializeShape($bp);

  let pp = ^meta::external::format::awspersistence::metamodel::AwsPersistence(
      documentation=$p.documentation,
      notifier=$p.notifier,
      trigger=$p.trigger,
      service=$p.service,
      // persister=$p.persister,
      target=$apt
    );

  $pp;
}


function <<access.private>> meta::external::format::awspersistence::serialization::serializeShape(bp: BatchPersister[1]): meta::external::format::awspersistence::metamodel::AwsPersistenceTarget[1..*]
{
  assert($bp.targetShape->instanceOf(FlatTarget), | 'AwsPersistence can currently only handle flat target shapes');
  let ft = $bp.targetShape->cast(@FlatTarget);

  let connection = $bp.connections;
  assertSize($bp.connections, 1, 'Expecting exactly one Persister connection, found %s', [$bp.connections->size()]);
  let c = $bp.connections->toOne();

  // FIXME: Should these be validated in a common place for all generators?
  let modelClass = $ft.modelClass;
  assert($modelClass.generalizations.general.rawType == Any, | 'AwsPersistence requires the class in targetShape to not be generalized (i.e., not extend another class)');

  let apt = serializeAwsPersistenceTarget($ft, $c, $modelClass);
  $apt->toOneMany();
}

function <<access.private>> meta::external::format::awspersistence::serialization::serializeAwsPersistenceTarget(ft: FlatTarget[1], c: Connection[1], modelClass: Class<Any>[1]): meta::external::format::awspersistence::metamodel::AwsPersistenceTarget[1]
{
  let properties = $modelClass.properties;
  let nonprimitives = $properties->filter(p|! $p.genericType.rawType->toOne()->instanceOf(PrimitiveType));
  assertEmpty($nonprimitives, 'Found non-primitive types in FlatTarget <%s>, only primitive types can be persisted', [$ft.targetName]);

  let pts = $properties->map(p|
    assertSize($p.name, 1, 'In FlatTarget <%s>, expected exactly one property name, found %s', [$ft.targetName, $p.name->size()]);
    assertSize($p.genericType.rawType, 1, 'In FlatTarget <%s> for property <%s>, expected exactly one type, found %s', [$ft.targetName, $p.name->toOne(), $p.genericType.rawType->size()]);
    ^meta::external::format::awspersistence::metamodel::AwsPersistenceTargetShapeProperties(name=$p.name->toOne(), awstype=$p.genericType.rawType->toOne());
  );
  assertSize($modelClass.name, 1, 'Expecting exactly one modelClass name, found %s', [$modelClass.name->size()]);
  assertSize($modelClass.package, 1, 'Expecting exactly one modelClass package, found %s', [$modelClass.package->size()]);
  
  assert($ft.deduplicationStrategy->instanceOf(NoDeduplicationStrategy), 'AwsPersistence can currently only handle NoDeduplicationStrategy in FlatTarget <%s>', [$ft.targetName]);

  let canHandle = 'NontemporalSnapshot, UnitemporalSnapshot';
  assertSize($ft.ingestMode, 1, 'A supported IngestMode (%s) must be specified for FlatTarget <%s>', [$canHandle, $ft.targetName]);

  $ft.ingestMode->toOne()->match([
    u:UnitemporalSnapshot[1]|assert($u.transactionMilestoning->instanceOf(BatchIdTransactionMilestoning), 'In FlatTarget %s, for UnitemporalSnapshot, only BatchIdTransactionMilestoning is supported', [$ft.targetName]),
    n:NontemporalSnapshot[1]|assert($n.auditing->instanceOf(NoAuditing), 'In FlatTarget %s, for NontemporalSnapshot, only NoAuditing is supported', [$ft.targetName]),
    a:Any[1]|assert(false, 'AwsPersistence can currently only handle %s milestoning in FlatTarget <%s>', [$canHandle, $ft.targetName])
  ]);

  let shape = ^meta::external::format::awspersistence::metamodel::AwsPersistenceTargetShape(name=$ft.modelClass.name->toOne(), package=$ft.modelClass.package->toOne(), properties=$pts);

  let apt = ^meta::external::format::awspersistence::metamodel::AwsPersistenceTarget(
      targetName=$ft.targetName,
      connection=$c,
      // deduplicationStrategy=$ft.deduplicationStrategy,
      ingestMode=$ft.ingestMode,
      shape=$shape
    );

  $apt;
}
